= Migrations

This guide is based on http://guides.rubyonrails.org/migrations.html

== Overview

Migrations make it easy to alter your database's schema in a systematic manner.
They make it easier to coordinate with other developers and make sure that
all developers are using the same database schema.

Migrations are optional, you don't have to use them.  You can always just
create the necessary database structure manually using Sequel's schema
modification methods or another database tool.  However, if you are dealing
with other developers, you'll have to send them all of the changes you are
making.  Even if you aren't dealing with other developers, you generally have
to make the schema changes in 3 places (development, testing, and then
production), and it's probably easier to use the migrations system to apply
the schema changes than it is to keep track of the changes manually and
execute them manually at the appropriate time.

Sequel tracks which migrations you have already run, so to apply migrations
you generally need to use run Sequel's migrator with <tt>bin/sequel -m</tt>:

  sequel -m path/to/migrations postgres://host/database

Migrations in Sequel use a very simple DSL via the <tt>Sequel.migration</tt>
method, and inside the DSL, use the <tt>Sequel::Database</tt> schema
modification methods such as +create_table+ and +alter_table+.

== A Basic Migration

Here is a fairly basic Sequel migration:

  Sequel.migration do
    up do
      create_table(:artists) do
        primary_key :id
        String :name, :null=>false
      end
    end

    down do
      drop_table(:artists)
    end
  end

This migration has an up block which adds an artist table with an integer primary key named id,
and a varchar or text column (depending on the database) named name that doesn't accept NULL values.
Migrations should include both up and down blocks, with the down block reversing
the change made by up.  However, if you never need to be able to migrate down
(i.e. you are one of the people that doesn't make mistakes), you can leave out
the down block.  In this case, the down block just reverses the changes made by up,
dropping the table.

In normal usage, when Sequel's migrator runs, it runs the up blocks for all
migrations that have not yet been applied.  However, you can use the <tt>-M</tt>
switch to specify the version to which to migrate, and if it is lower than the
current version, Sequel will run the down block on the appropriate migrations.

You are not limited to creating tables inside a migration, you can alter existing tables
as well as modify data.  Let's say your artist database originally only included artists
from Sacramento, CA, USA, but now you want to branch out and include artists in any city:

  Sequel.migration do
    up do
      add_column :artists, :location, String
      self[:artists].update(:location=>'Sacramento')
    end

    down do
      drop_column :artists, :location
    end
  end

This migration adds a +location+ column to the +artists+ table, and sets the +location+ column
to <tt>'Sacramento'</tt> for all existing artists.  It doesn't use a default on the column,
because future artists should not be assumed to come from Sacramento.  In the down block, it
just drops the +location+ column from the +artists+ table, reversing the actions of the up
block.

Note that when updating the +artists+ table in the update, a plain dataset is used, <tt>self[:artists]</tt>.
This looks a little weird, but you need to be aware that inside an up or down block in a migration,
self always refers to the <tt>Sequel::Database</tt> object that the migration is being applied to.
Since <tt>Database#[]</tt> creates datasets, using <tt>self[:artists]</tt> inside the up block creates
a dataset on the database representing all columns in the +artists+ table, and updates it to set the
+location+ column to <tt>'Sacramento'</tt>.

It is possible to use model classes inside migrations, as long as they are loaded into the ruby interpreter,
but it's a bad habit as changes to your model classes can then break old migrations, and this breakage is
often not caught until much later, such as when a new developer joins the team and wants to run all migrations
to create their development database.

== The +migration+ extension

The migration code is not technically part of the core of Sequel.  It's not loaded by default as it
is only useful in specific cases.  It is one of the built-in extensions, which receive the same
level of support as Sequel's core.

If you want to play with Sequel's migration tools without using the <tt>bin/sequel</tt> tool, you
need to load the migration extension manually:

  Sequel.extension :migration

== Schema methods

Migrations themselves do not contain any schema modification methods, but they make it easy to call
any of the <tt>Sequel::Database</tt> modification methods, of which there are many.  The main
ones are +create_table+ and +alter_table+, but Sequel also comes with numerous other schema
modification methods, most of which are shortcuts for +alter_table+ (all of these methods are
described in more detail later):

* add_column
* add_index
* create_view
* drop_column
* drop_index
* drop_table
* drop_view
* rename_table
* rename_column
* set_column_default
* set_column_type

These methods handle the vast majority of cross database schema modification SQL.  If you
need to drop down to SQL to execute some database specific code, you can use the +run+
method:

  Sequel.migration do
    up{run 'CREATE TRIGGER ...'}
    down{run 'DROP TRIGGER ...'}
  end

In this case, we are using { and } instead of do and end to define the blocks. Just as
before, the +run+ methods inside the blocks are called on the +Database+ object,
which just executes the code on the underlying database.

== Errors when running migrations

Sequel attempts to run migrations inside of a transaction.  Some databases do not support
schema modifications made in transactions, and if the migration raises an error, it will
not rollback the previous schema changes made by the migration.  In that case, you will
need to update the database by hand.

It's recommended to always run migrations on a test database and ensure they work
before running them on any production database.

== Migration files

While you can create migration objects yourself and apply them manually, most of the
benefit to using migrations come from using Sequel's +Migrator+, which is what the
<tt>bin/sequel -m</tt> switch does.  Sequel's +Migrator+ expects that each migration
will be in a separate file in a specific directory.  The <tt>-m</tt> switch requires an
argument be specified that is the path to the directory containing the migration files.
For example:

  sequel -m db/migrations postgres://localhost/sequel_test

will look in the <tt>db/migrations</tt> folder relative to the current directory,
and run unapplied migrations on the PostgreSQL database sequel_test running on localhost.

== Two separate migrators

Sequel actually ships with two separate migrators.  One is the +IntegerMigrator+, the other is
the +TimestampMigrator+.  They both have plusses and minuses:

=== +IntegerMigrator+

* Simpler, uses migration versions starting with 1
* Doesn't allow duplicate migrations
* Doesn't allow missing migrations
* Just stores the version of the last migration run
* Good for single developer or small teams with close
  communication
* Lower risk of undetected conflicting migrations
* Requires manual merging of simultaneous migrations

=== +TimeStampMigrator+

* More complex, use migration versions where the version should
  represent a timestamp
* Allows duplicate migrations (since you could have multiple in a given second)
* Allows missing migrations (since you obviously don't have one every second)
* Stores the file names of all applied migrations
* Good for large teams without close communication
* Higher risk of undected conflicting migrations
* Does not require manual merging of simultaneous migrations

=== Filenames

In order for migration files to work with the Sequel, they must be specified as follows:

  version_name.rb

where <tt>version</tt> is an integer and <tt>name</tt> is a string which should be a very brief
description of what the migration does.  Each migration class should contain 1 and only 1
call to <tt>Sequel.migration</tt>.

=== +IntegerMigrator+ Filenames

These are valid migration names for the +IntegerMigrator+:

  1_create_artists.rb
  2_add_artist_location.rb

The only problem with this naming format is that if you have more than 9 migrations, the 10th
one will look a bit odd:

  1_create_artists.rb
  2_add_artist_location.rb
  ...
  9_do_something.rb
  10_do_something_else.rb

For this reasons, it's often best to start with 001 instead of 1, as that means you don't need
to worry about that issue until the 1000th migration:

  001_create_artists.rb
  002_add_artist_location.rb
  ...
  009_do_something.rb
  010_do_something_else.rb

It should be fairly obvious, but migrations start at 1, not 0.  The migration version number 0
is important though, as it is used to mean that all migrations should be unapplied (i.e. all
down blocks run).  In Sequel, you can do that with:

  sequel -m db/migrations -M 0 postgres://localhost/sequel_test

=== +TimestampMigrator+ Filenames

With the +TimestampMigrator+, the version integer should represent a timestamp, though this isn't strictly
required.  

For example, for <tt>5/10/2010 12:00:00pm</tt>, you could use any of the following formats:

  # Date
  20100510_create_artists.rb

  # Date and Time
  20100510120000_create_artists.rb

  # Unix Epoch Time Integer
  1273518000_create_artists.rb

The important thing is that all migration files should be in the same format, otherwise when you
update, it'll be difficult to make sure migrations are applied in the correct order, as well as
be difficult to unapply some the affected migrations correctly.

The +TimestampMigrator+ will be used if any filename in the migrations directory has a version
greater than 20000101.  Otherwise, the +IntegerMigrator+ will be used.

=== How to choose

Basically, unless you need the features provided by the +TimestampMigrator+, stick with the
+IntegerMigrator+, as it is simpler and makes it easier to detect possible errors.

For a single developer, the +TimestampMigrator+ has no real benefits, so I would always recommend
the +IntegerMigrator+.  When dealing with multiple developers, it depends on the size of the
development team, the team's communication level, and the level of overlap between developers.

Let's say Alice works on a new feature that requires a migration at the same time Bob works
on a separate feature that requires an unrelated migration.  If both developers are committing
to their own private respositories, when it comes time to merge, the +TimestampMigrator+ will not
require any manually changes.  That's because Alice will have a migration such as
<tt>20100512_do_this.rb</tt> and Bob will have one such as <tt>20100512_do_that.rb</tt>.

If the +IntegerMigrator+ was used, Alice would have <tt>34_do_this.rb</tt> and Bob would have
<tt>34_do_that.rb</tt>.  When the +IntegerMigrator+ was used, it would raise an exception due to
the duplicate migration version.  The only way to fix it would be to renumber one of the two
migrations, and have the affected developer manually modify their database.

So for unrelated migrations, the +TimestampMigrator+ works fine.  However, let's say that the
migrations are related, in such a way that if Bob's is run first, Alice's will fail.  In this
case, the +TimestampMigrator+ would not raise an error when Bob merges Alice's changes, since
Bob ran his migration first.  However, it would raise an error when Alice runs Bob's migration,
and could leave the database in an inconsistant state if the database doesn't support transactional
schema changes.

With the +TimestampMigrator+, you are trading reliability for convenience.  That's possibly a valid
trade, especially if simultaneous related schema changes by separate developers are unlikely, but
you should give it some thought before using it.

== Modifying existing migrations

Just don't do it.

In general, you should not modify any migration that has been run on the database and been committed
the source control repository, unless the migration contains a error that causes data loss.  As long
as it is possible to undo the migration without losing data, you should just add another migration
that undoes the actions of the previous bad migration, and maybe does the correct action afterward.

The main problem with modifying existing migrations is that you will have to manually modify any
databases that ran the migration before it was modified.  If you are a single developer, that may be
an option, but certainly if you have multiple developers, it's a lot more work.

== Creating a migration

Sequel doesn't come with generators that create migrations for you.  However, creating a migration
is as simple as creating a file with the appropriate filename in your migrations directory that
contains a <tt>Sequel.migration</tt> call.  The minimal do-nothing migration is:

  Sequel.migration{}

However, the migrations you right should contain an up block that does something, and a down block that
reverses the changes made by up:

  Sequel.migration do
    up{...}
    down{...}
  end

== Schema modification methods

Inside your migration's down and up blocks is where you will call the +Database+ schema modification methods.
Here's a brief description of the most common schema modification methods:

=== +create_table+

+create_table+ is the most common schema modification method, and it's used for adding new tables
to the schema.  You provide it with the name of the table as a symbol, as well a block:

  create_table(:artists) do
    primary_key :id
    String :name
  end

Not that if you want a primary key for the table, you need to specify it, Sequel does not create one
by default.

==== Column types

Most method calls inside the create_table block will create columns, though the index method
will create an index.  Columns are generally created by specifying the column type as the method
name, followed by the column name symbol to use, and after that any options that should be used.
If the method is a ruby class name that Sequel recognizes, Sequel will transform it into the appropriate
type for the given database.  So while you specified +String+, Sequel will actually use +varchar+ or
+text+ depending on the underlying database.  Here's a list of all of ruby classes that Sequel will
convert to database types:

  create_table(:columns_types) do       # common database type used
    Integer :a0                         # integer
    String :a1                          # varchar(255)
    String :a2, :size=>50               # varchar(50)
    String :a3, :fixed=>true            # char(255)
    String :a4, :fixed=>true, :size=>50 # char(50)
    String :a5, :text=>true             # text
    File :b,                            # blob
    Fixnum :c                           # integer
    Bignum :d                           # bigint
    Float :e                            # double precision
    BigDecimal :f                       # numeric
    BigDecimal :f2, :size=>10           # numeric(10)
    BigDecimal :f3, :size=>[10, 2]      # numeric(10, 2)
    Date :g                             # date
    DateTime :h                         # timestamp
    Time :i                             # timestamp
    Time :i2, :only_time=>true          # time
    Numeric :j                          # numeric
    TrueClass :k                        # boolean
    FalseClass :l                       # boolean
  end

Note that in addition to the ruby class name, Sequel also pays attention to the column options when
determining which database type to use.

Also note that this conversion is only done if you use a supported ruby class name.  In all other
cases, Sequel uses the type specified verbatim:

  create_table(:columns_types) do  # database type used
    string :a1                     # string
    datetime :a2                   # datetime
    blob :a3                       # blob
    inet :a4                       # inet
  end

In addition to specifying the types as methods, you can use the column method and specify the types
as the second argument, either as ruby classes, symbols, or strings:

  create_table(:columns_types) do  # database type used
    column :a1, :string            # string
    column :a2, String             # varchar(255)
    column :a3, 'string'           # string
    datetime :a2                   # datetime
    blob :a3                       # blob
    inet :a4                       # inet
  end

